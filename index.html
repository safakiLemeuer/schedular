/**
 * ai.js — Claude + DALL-E API Module
 *
 * CALL DISCIPLINE:
 *   Claude ONLY for: JUDGMENT | SUMMARIZATION | STRATEGY | AMBIGUITY | GENERATION
 *   Claude NEVER for: boolean checks, formatting, filtering, regex,
 *                     JSON transforms, date math, keyword matching, timing rules
 *
 * BHT CONTENT GUARDRAILS — injected into every Claude system prompt:
 *   1.  No em dash in any form
 *   2.  No "60% processing time reduction" (unverified)
 *   3.  No SEC as direct client (subcontractor only)
 *   4.  No DOJ as direct client (subcontractor only — name the prime)
 *   5.  No DHS as direct client (subcontractor to HHREF, 2004-2010)
 *   6.  No GSA MAS as current vehicle (in pursuit, not awarded)
 *   7.  No BHT Insight as current product (concept stage only)
 *   8.  No unverifiable budget/policy citations
 *   9.  No forward-looking claims stated as current capability
 *   10. No "solution" as a marketing noun
 *   11. No template-sounding sentences
 */
'use strict';

const Anthropic = require('@anthropic-ai/sdk');
const axios     = require('axios');
const fs        = require('fs');
const path      = require('path');

// ── BHT guardrails — single source of truth, injected into EVERY Claude prompt
// and embedded in every DALL-E prompt. Nothing generated by this system may
// violate these rules. They are not suggestions.
const BHT_GUARDRAILS = `
ABSOLUTE CONTENT RULES — these override all other instructions:

1. NO EM DASH in any form. Not the Unicode em dash character (—). Not double-hyphen (--) used as an em dash. Use a comma, a colon, or rewrite the sentence.
2. NEVER cite "60% processing time reduction." This figure is unverified and is permanently excluded from all BHT content.
3. NEVER describe the SEC as a direct client. BHT's SEC work was a subcontractor engagement only. Do not imply otherwise.
4. NEVER describe the DOJ as a direct client. Subcontractor engagements only. If DOJ is mentioned at all, name the prime contractor.
5. NEVER describe DHS as a direct client. BHT was subcontractor to HHREF from 2004 to 2010. That is the only correct characterization.
6. NEVER refer to GSA MAS as a current contract vehicle. GSA MAS is in pursuit, not awarded. Do not imply BHT holds it.
7. NEVER refer to BHT Insight as a current product. It is at concept stage only. Do not imply it is deployed, available, or shipping.
8. NO unverifiable budget citation or policy reference. If a dollar figure or policy citation cannot be confirmed from public record, omit it.
9. NO forward-looking capability stated as current. If BHT does not do it today, do not write as though it does.
10. NEVER use "solution" as a marketing noun (e.g., "our AI solution," "compliance solution"). Replace with specific nouns: framework, process, system, platform, approach.
11. NO sentence that reads like it came from a template. No "in today's rapidly evolving landscape," no "at the forefront of," no "committed to excellence." Write specifically.
`.trim();

// ── Lazy clients ───────────────────────────────────────────────────────────
let _claude = null;
function getClaudeClient() {
  const key = process.env.ANTHROPIC_API_KEY;
  if (!key) throw new Error('ANTHROPIC_API_KEY not set');
  if (!_claude) _claude = new Anthropic({ apiKey: key });
  return _claude;
}
function getOpenAIKey() {
  const key = process.env.OPENAI_API_KEY;
  if (!key) throw new Error('OPENAI_API_KEY not set — image generation disabled');
  return key;
}

// ── Cache ──────────────────────────────────────────────────────────────────
const _cache    = new Map();
const CACHE_TTL = 3600000; // 1 hour
const CACHE_MAX = 500;

function _cacheGet(k) {
  const e = _cache.get(k);
  if (!e) return null;
  if (Date.now() - e.ts > CACHE_TTL) { _cache.delete(k); return null; }
  return e.val;
}
function _cacheSet(k, val) {
  if (_cache.size >= CACHE_MAX) {
    let ok = null, ots = Infinity;
    for (const [mk, mv] of _cache) { if (mv.ts < ots) { ots = mv.ts; ok = mk; } }
    if (ok) _cache.delete(ok);
  }
  _cache.set(k, { val, ts: Date.now() });
}

// ── Usage log ──────────────────────────────────────────────────────────────
const _log = [];
function _record(fn, tokIn, tokOut, cached, model) {
  _log.push({ fn, tokens_in: tokIn, tokens_out: tokOut, cached, model, ts: Date.now() });
  if (_log.length > 1000) _log.splice(0, _log.length - 1000);
}

// ── Core Claude wrapper — only place that touches the Anthropic API ────────
async function _call({ fnName, system, user, maxTokens }) {
  const ck  = `${fnName}:${(system + user).slice(0, 300)}`;
  const hit = _cacheGet(ck);
  if (hit !== null) { _record(fnName, 0, 0, true, 'haiku'); return hit; }

  const est = Math.ceil((system.length + user.length) / 4);
  console.log(`[AI] Claude: ${fnName} (~${est} in, max ${maxTokens} out)`);

  const msg = await getClaudeClient().messages.create({
    model:      'claude-haiku-4-5-20251001',
    max_tokens: maxTokens,
    system:     `${system}\n\n${BHT_GUARDRAILS}`,
    messages:   [{ role: 'user', content: user }],
  });

  const text   = msg.content[0]?.text?.trim() ?? '';
  const tokIn  = msg.usage?.input_tokens  ?? est;
  const tokOut = msg.usage?.output_tokens ?? 0;
  _record(fnName, tokIn, tokOut, false, 'haiku');
  _cacheSet(ck, text);
  return text;
}

// ═══════════════════════════════════════════════════════════════════════════
// SECTION A — PURE JS (zero API calls)
// ═══════════════════════════════════════════════════════════════════════════

function validatePostLocally(post) {
  const blocking = [], warnings = [];
  if (!post.body  || post.body.trim().length  === 0) blocking.push('Post body is empty');
  if (!post.title || post.title.trim().length === 0) blocking.push('Title is required');
  if (!post.scheduled_at)                            blocking.push('Scheduled date is required');
  if (post.body && post.body.length > 3000)
    blocking.push(`Post is ${post.body.length} chars — LinkedIn limit is 3000`);
  if (post.scheduled_at) {
    const d = new Date(post.scheduled_at);
    if (isNaN(d.getTime()))  blocking.push('Scheduled date is not valid');
    else if (d < new Date()) warnings.push('Scheduled time is in the past');
  }
  if (post.hashtags) {
    const n = (post.hashtags.match(/#\w+/g) || []).length;
    if (n > 10) warnings.push(`${n} hashtags — LinkedIn recommends 3-5`);
  }
  if (post.body && post.body.length > 500 && !/https?:\/\/\S+/.test(post.body))
    warnings.push('Long post with no URL — consider adding a CTA link');
  return { blocking, warnings };
}

function isStandardDate(str) {
  if (!str || typeof str !== 'string') return false;
  const s = str.trim();
  const ok = [
    /^\d{4}-\d{2}-\d{2}/,
    /^\d{1,2}[\/\-]\d{1,2}[\/\-]\d{2,4}/,
    /^\d{1,2}\s+\w+\s+\d{4}/,
    /^\w+\s+\d{1,2},?\s+\d{4}/,
  ].some(p => p.test(s));
  return ok && !isNaN(new Date(s).getTime());
}

function detectContentType(body) {
  if (!body) return 'general';
  const t = body.toLowerCase();
  const rules = [
    { type: 'product-launch',     re: /\b(launch|introducing|announcing|we built|shipping|now live)\b/ },
    { type: 'case-study',         re: /\b(case study|results|achieved|saved|reduced|increased|roi)\b/ },
    { type: 'vision',             re: /\b(vision|future|202[7-9]|category|infrastructure)\b/ },
    { type: 'proof',              re: /\b(audit|found|numbers|data show|we ran|scanned)\b/ },
    { type: 'insight',            re: /\b(lesson|learned|mistake|what i found|the gap|insight)\b/ },
    { type: 'educational',        re: /\b(how to|framework|step \d|thread|checklist|guide)\b/ },
    { type: 'thought-leadership', re: /\b(broken|wrong|nobody talks|problem is|here is what)\b/ },
  ];
  for (const { type, re } of rules) { if (re.test(t)) return type; }
  return 'general';
}

// Auto-schedule: pure date math + lookup table.
// Returns first available slot that matches content type and has no collision.
function autoSchedule(post, takenDates) {
  const TIMING = {
    'product-launch':     { days: [1,2,3], hour: 8 },
    'case-study':         { days: [2,3,4], hour: 9 },
    'vision':             { days: [5],     hour: 8 },
    'proof':              { days: [2,3],   hour: 8 },
    'insight':            { days: [3,4],   hour: 9 },
    'educational':        { days: [1,2],   hour: 8 },
    'thought-leadership': { days: [2,3,4], hour: 8 },
    'general':            { days: [2],     hour: 8 },
  };
  const contentType = detectContentType(post.body || post.title || '');
  const rule  = TIMING[contentType] || TIMING['general'];
  const taken = new Set((takenDates || []).map(d => new Date(d).toISOString().slice(0,10)));

  const d = new Date();
  d.setDate(d.getDate() + 1);
  let walked = 0;
  while (walked < 60) {
    const dow     = d.getDay();
    const dateStr = d.toISOString().slice(0,10);
    if (rule.days.includes(dow) && !taken.has(dateStr)) {
      const slot = new Date(d);
      slot.setHours(rule.hour, 0, 0, 0);
      return { iso: slot.toISOString(), contentType };
    }
    d.setDate(d.getDate() + 1);
    walked++;
  }
  // Fallback: next Tuesday
  const fb = new Date();
  fb.setDate(fb.getDate() + ((2 - fb.getDay() + 7) % 7 || 7));
  fb.setHours(8, 0, 0, 0);
  return { iso: fb.toISOString(), contentType };
}

function suggestPostTiming(post, takenDates) {
  const r = autoSchedule(post, takenDates || []);
  return { recommended_slot: r.iso, content_type: r.contentType, source: 'js' };
}

function normaliseRow(raw) {
  return {
    title:        raw.title        || raw.Title        || raw.TITLE           || '',
    body:         raw.body         || raw.Body         || raw.BODY            || raw.content || raw.Content || '',
    scheduled_at: raw.scheduled_at || raw['Scheduled At'] || raw.ScheduledAt || raw.date    || raw.Date    || '',
    hashtags:     raw.hashtags     || raw.Hashtags     || raw.HASHTAGS        || '',
    campaign:     raw.campaign     || raw.Campaign     || raw.campaign_name   || raw['Campaign Name'] || '',
  };
}

function formatDateShort(dt) {
  return dt ? new Date(dt).toLocaleDateString('en-US', { month:'short', day:'numeric' }) : '';
}

function parseClaudeJSON(str) {
  if (!str) return null;
  try {
    return JSON.parse(str.replace(/^```(?:json)?\s*/i,'').replace(/\s*```\s*$/i,'').trim());
  } catch { return null; }
}

function getUsageStats() {
  const now = Date.now(), MS24 = 86400000, MS7D = 7 * MS24;
  const sum = arr => ({
    calls:       arr.filter(e => !e.cached).length,
    cached_hits: arr.filter(e =>  e.cached).length,
    tokens_in:   arr.reduce((s,e) => s + e.tokens_in,  0),
    tokens_out:  arr.reduce((s,e) => s + e.tokens_out, 0),
  });
  const byFn = _log.reduce((acc, e) => {
    if (!acc[e.fn]) acc[e.fn] = { calls:0, cached:0, tokens_in:0, tokens_out:0 };
    e.cached ? acc[e.fn].cached++ : acc[e.fn].calls++;
    acc[e.fn].tokens_in  += e.tokens_in;
    acc[e.fn].tokens_out += e.tokens_out;
    return acc;
  }, {});
  return {
    cache_entries: _cache.size,
    last_24h:     sum(_log.filter(e => now - e.ts < MS24)),
    last_7d:      sum(_log.filter(e => now - e.ts < MS7D)),
    all_time:     sum(_log),
    by_function:  Object.entries(byFn).map(([fn,s]) => ({ fn, ...s })),
  };
}

// ═══════════════════════════════════════════════════════════════════════════
// SECTION B — CLAUDE FUNCTIONS
// ═══════════════════════════════════════════════════════════════════════════

// JUDGMENT — post quality / brand compliance
// JS validatePostLocally runs first; blocking issues skip Claude.
async function reviewPostQuality(post) {
  const local = validatePostLocally(post);
  if (local.blocking.length > 0)
    return { approved: false, issues: local.blocking, warnings: local.warnings, source: 'js' };
  try {
    const raw = await _call({
      fnName: 'reviewPostQuality', maxTokens: 200,
      system: [
        'You are a LinkedIn content quality reviewer for TheBHTLabs.',
        'Respond JSON only. Schema: {"approved":boolean,"issues":[],"suggestion":""}',
        'Flag ONLY: incoherent logic, contradictory claims, unprofessional tone, reputational risk.',
        'Do NOT flag style, opinions, or formatting. One sentence for "suggestion" max.',
      ].join('\n'),
      user: `Title: ${post.title}\n\nBody:\n${post.body.slice(0, 800)}`,
    });
    const parsed = parseClaudeJSON(raw);
    if (!parsed) return { approved: true, issues: [], warnings: local.warnings, source: 'parse-failed' };
    return { ...parsed, warnings: local.warnings, source: 'claude' };
  } catch (err) {
    console.warn('[AI] reviewPostQuality:', err.message);
    return { approved: true, issues: [], warnings: local.warnings, source: 'fallback' };
  }
}

// AMBIGUITY — dates JS cannot parse
// isStandardDate() filters parseable rows first.
async function resolveAmbiguousDates(rows, referenceDate) {
  const ambiguous = rows.filter(r => !isStandardDate(r.scheduled_at));
  if (ambiguous.length === 0) return [];
  const unique = [...new Set(ambiguous.map(r => r.scheduled_at))];
  try {
    const raw = await _call({
      fnName: 'resolveAmbiguousDates', maxTokens: 300,
      system: [
        `Reference date (today): ${new Date(referenceDate).toISOString().slice(0,10)}`,
        'Resolve each line to ISO 8601 datetime. Default time 08:00:00Z.',
        'JSON array only: [{"original":"...","resolved":"YYYY-MM-DDTHH:MM:00Z"}]',
        'Use null for "resolved" if cannot be interpreted.',
      ].join('\n'),
      user: unique.join('\n'),
    });
    const resolved = parseClaudeJSON(raw) || [];
    const lookup = Object.fromEntries(resolved.filter(r => r.resolved).map(r => [r.original, r.resolved]));
    return ambiguous.map(r => ({
      ...r,
      scheduled_at:  lookup[r.scheduled_at] ?? r.scheduled_at,
      date_resolved: !!lookup[r.scheduled_at],
    }));
  } catch (err) {
    console.warn('[AI] resolveAmbiguousDates:', err.message);
    return ambiguous.map(r => ({ ...r, date_resolved: false }));
  }
}

// SUMMARIZATION — extract core claim from long body
// Posts under 200 chars handled by JS. Body sliced to 1000 chars.
async function summarizePost(body) {
  if (!body || body.length < 200) return (body || '').slice(0, 160);
  try {
    return await _call({
      fnName: 'summarizePost', maxTokens: 80,
      system: '1-2 sentences. Lead with the core claim. No preamble. No "This post...".',
      user:   body.slice(0, 1000),
    });
  } catch (err) {
    const first = body.match(/[^.!?]+[.!?]/)?.[0]?.trim() ?? body.slice(0, 160);
    return first.length > 160 ? first.slice(0,157) + '...' : first;
  }
}

// STRATEGY — narrative arc audit across campaign sequence
// JS sorts + formats; Claude sees titles only, not full bodies.
async function auditCampaignNarrative(posts) {
  if (!posts || posts.length < 2) return { verdict: 'ok', notes: [], source: 'js' };
  const sequence = [...posts]
    .sort((a,b) => new Date(a.scheduled_at) - new Date(b.scheduled_at))
    .map((p,i) => `${i+1}. [${formatDateShort(p.scheduled_at)}] ${p.title}`)
    .join('\n');
  try {
    const raw = await _call({
      fnName: 'auditCampaignNarrative', maxTokens: 250,
      system: [
        'Audit LinkedIn campaign post sequences for structural narrative problems.',
        'JSON only: {"verdict":"ok|warning|broken","notes":[]}',
        'Flag: repeated messaging, proof before problem, abrupt shifts, missing arc.',
        'Do not rewrite posts. One sentence per note.',
      ].join('\n'),
      user: `Sequence:\n${sequence}`,
    });
    const parsed = parseClaudeJSON(raw);
    return parsed ? { ...parsed, source: 'claude' } : { verdict: 'ok', notes: [], source: 'parse-failed' };
  } catch (err) {
    console.warn('[AI] auditCampaignNarrative:', err.message);
    return { verdict: 'ok', notes: [], source: 'fallback' };
  }
}

// GENERATION — hashtags (requires understanding post content + target audience)
// JS gate: if post already has hashtags, skip entirely.
// JS regex extracts tags from Claude response — Claude does not parse itself.
// JS fallback: content-type default tag set if Claude fails.
async function generateHashtags(post) {
  if (post.hashtags && post.hashtags.trim().length > 0) return post.hashtags.trim();
  try {
    const raw = await _call({
      fnName: 'generateHashtags', maxTokens: 60,
      system: [
        'Write LinkedIn hashtags for TheBHTLabs, an AI governance and federal compliance firm.',
        'Return 4-6 hashtags on one line, space-separated, each starting with #.',
        'Target audience: federal technology leaders, AI compliance officers, CISOs.',
        'Use specific tags: #AIGovernance over #AI, #FedTech over #Technology.',
        'Do NOT use: #Solution, #Solutions — these violate BHT brand rules.',
        'Do NOT use hashtags that imply DHS, SEC, or DOJ are direct clients.',
        'Hashtags only. No explanation. No other text.',
      ].join('\n'),
      user: `Title: ${post.title}\nFirst 300 chars: ${(post.body||'').slice(0,300)}`,
    });
    // Extract hashtags with regex — JS, not Claude
    const tags = (raw.match(/#\w+/g) || []).slice(0, 6);
    return tags.length > 0 ? tags.join(' ') : null;
  } catch (err) {
    console.warn('[AI] generateHashtags:', err.message);
    // JS fallback lookup table — not Claude
    const DEFAULTS = {
      'product-launch':     '#AIGovernance #GovTech #AICompliance #FedTech',
      'thought-leadership': '#AIGovernance #FederalTechnology #Compliance #Leadership',
      'case-study':         '#AIGovernance #FedTech #AICompliance #Results',
      'educational':        '#AIGovernance #Compliance #EUAIAct #NIST',
      'vision':             '#AIGovernance #FutureFed #AIPolicy #Leadership',
      'general':            '#AIGovernance #FedTech #Compliance',
    };
    return DEFAULTS[detectContentType(post.body)] || DEFAULTS['general'];
  }
}

// GENERATION — DALL-E 3 image prompt (requires visual interpretation of post content)
// Claude writes the DALL-E prompt; DALL-E renders it. Two separate API calls.
// Guardrails injected at both stages: Claude prompt + final DALL-E string.
async function generateImagePrompt(post) {
  const contentType = detectContentType(post.body || '');

  // Visual style lookup — JS table, not Claude
  const STYLE = {
    'product-launch':     'clean product interface mockup, teal and navy palette, modern tech aesthetic',
    'thought-leadership': 'abstract geometric shapes, navy and white, editorial photograph style',
    'case-study':         'clean data visualization aesthetic, professional blue tones, minimal charts',
    'vision':             'wide-angle futuristic minimal scene, teal accents on dark navy, aspirational',
    'proof':              'clean dashboard interface, teal highlights, white background, professional',
    'insight':            'single symbolic object, high contrast, white background, conceptual photography',
    'educational':        'clean diagram aesthetic, navy and teal color blocks, professional minimal',
    'general':            'abstract minimal geometry, teal and navy, professional corporate photography',
  };
  const styleGuide = STYLE[contentType] || STYLE['general'];

  try {
    const raw = await _call({
      fnName: 'generateImagePrompt', maxTokens: 150,
      system: [
        'Write a DALL-E 3 image generation prompt for a TheBHTLabs LinkedIn post.',
        'Brand: AI governance and federal compliance firm. Colors: teal #31748E, navy #12284C.',
        'The image MUST contain NO text, words, letters, numbers, or labels of any kind.',
        'The image MUST NOT contain: government seals, agency logos, dollar amounts, percentages,',
        '  or any visual that implies a specific federal agency relationship.',
        'The image MUST be suitable for a professional B2B LinkedIn audience.',
        `Required style: ${styleGuide}`,
        'Output: a single prompt string under 120 words. No explanation. No preamble.',
      ].join('\n'),
      user: `Post title: ${post.title}\nContent type: ${contentType}\nPost opening: ${(post.body||'').slice(0,200)}`,
    });

    // Sanitise the prompt before sending to DALL-E — JS string replacement, not Claude
    const cleaned = raw.trim()
      .replace(/\b(SEC|DOJ|DHS|GSA|HHREF)\b/gi, 'federal agency')  // no specific agency refs
      .replace(/\d+%/g, '')                                           // no percentages
      .replace(/\$[\d,]+/g, '');                                      // no dollar amounts

    return cleaned || `Professional ${contentType} LinkedIn image, ${styleGuide}, no text`;
  } catch (err) {
    console.warn('[AI] generateImagePrompt:', err.message);
    return `Professional ${contentType} LinkedIn image, ${styleGuide}, no text or words, high quality, photorealistic`;
  }
}

// DALL-E 3 image generation — NOT a Claude call
// Claude generates the prompt above; this function sends it to OpenAI Images.
async function generatePostImage(post, uploadsDir) {
  const prompt = await generateImagePrompt(post);
  console.log(`[AI] DALL-E generating image for post ${post.id}: "${prompt.slice(0, 80)}..."`);

  const imgRes = await axios.post(
    'https://api.openai.com/v1/images/generations',
    {
      model:   'dall-e-3',
      prompt:  prompt + ' No text or words in the image.',
      n:       1,
      size:    '1024x1024',
      quality: 'standard',
      style:   'natural',
    },
    { headers: { Authorization: `Bearer ${getOpenAIKey()}`, 'Content-Type': 'application/json' } }
  );

  const imageUrl = imgRes.data.data[0]?.url;
  if (!imageUrl) throw new Error('DALL-E returned no image URL');

  const dlRes    = await axios.get(imageUrl, { responseType: 'arraybuffer' });
  const filename = `ai-img-${post.id}-${Date.now()}.png`;
  const filePath = path.join(uploadsDir, filename);
  fs.writeFileSync(filePath, dlRes.data);

  _record('generatePostImage_dalle3', 0, 0, false, 'dall-e-3');
  console.log(`[AI] Image saved: ${filename}`);
  return { filename, filePath, prompt };
}

module.exports = {
  // Claude functions
  reviewPostQuality,
  resolveAmbiguousDates,
  summarizePost,
  auditCampaignNarrative,
  generateHashtags,
  generatePostImage,
  // Pure JS functions
  validatePostLocally,
  isStandardDate,
  normaliseRow,
  detectContentType,
  autoSchedule,
  suggestPostTiming,
  formatDateShort,
  parseClaudeJSON,
  getUsageStats,
  BHT_GUARDRAILS,
};
